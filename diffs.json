[
  {
    "path": "infra/db.py",
    "content_after": "# infra/db.py\nfrom __future__ import annotations\n\nimport os\nfrom contextlib import contextmanager\nfrom typing import Iterator, Optional\n\n# Streamlit peut ne pas √™tre dispo en contexte tests -> importer prudemment\ntry:\n    import streamlit as st  # type: ignore\nexcept Exception:  # pragma: no cover\n    st = None  # type: ignore\n\nfrom sqlalchemy import create_engine, text\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.orm import sessionmaker, Session\n\n_ENGINE: Optional[Engine] = None\n_SESSION_FACTORY: Optional[sessionmaker] = None\n_BOOTSTRAPPED: bool = False\n\ndef _db_url() -> str:\n    # 1) Streamlit secrets  2) fallback os.getenv\n    url = None\n    try:\n        if st is not None:\n            url = st.secrets.get(\"database\", {}).get(\"url\")  # type: ignore\n    except Exception:\n        pass\n    return url or os.getenv(\"DATABASE_URL\", \"\")\n\ndef get_engine() -> Engine:\n    global _ENGINE, _SESSION_FACTORY\n    if _ENGINE is None:\n        url = _db_url()\n        if not url:\n            raise RuntimeError(\n                \"DATABASE_URL manquant (st.secrets['database']['url'] ou variable d'environnement).\"\n            )\n        _ENGINE = create_engine(\n            url,\n            pool_size=5,\n            max_overflow=0,\n            pool_pre_ping=True,\n            pool_recycle=1800,\n            future=True,\n        )\n        _SESSION_FACTORY = sessionmaker(bind=_ENGINE, expire_on_commit=False, future=True)\n    return _ENGINE\n\n@contextmanager\ndef get_session(readonly: bool = False) -> Iterator[Session]:\n    if _SESSION_FACTORY is None:\n        get_engine()\n    assert _SESSION_FACTORY is not None\n    session = _SESSION_FACTORY()\n    try:\n        if readonly:\n            session.execute(text(\"SET TRANSACTION READ ONLY\"))\n        yield session\n        if not readonly:\n            session.commit()\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n\ndef bootstrap_after_create() -> None:\n    \"\"\"\n    Idempotent : ins√®re les WODs 26.x + cr√©e les index si absents.\n    Appel√©e apr√®s Base.metadata.create_all(...).\n    \"\"\"\n    global _BOOTSTRAPPED\n    if _BOOTSTRAPPED:\n        return\n    engine = get_engine()\n    with engine.begin() as conn:\n        # Seed 'wods' (ON CONFLICT pour idempotence)\n        conn.execute(text(\"\"\"\n            INSERT INTO wods (wod, label, type, timecap_seconds)\n            VALUES \n              ('26.1', 'Open 26.1', 'reps', NULL),\n              ('26.2', 'Open 26.2', 'time', 12*60),\n              ('26.3', 'Open 26.3', 'time', 20*60)\n            ON CONFLICT (wod) DO NOTHING;\n        \"\"\"))\n\n        # Index idempotents\n        conn.execute(text(\"CREATE INDEX IF NOT EXISTS idx_scores_user_wod ON scores(user_id, wod);\"))\n        conn.execute(text(\"CREATE INDEX IF NOT EXISTS idx_users_sex_level ON users(sex, level);\"))\n    _BOOTSTRAPPED = True\n"
  },
  {
    "path": "pages/Authentification.py",
    "content_after": "import streamlit as st\nfrom datetime import datetime\nfrom sqlalchemy import (\n    Column,\n    Integer,\n    String,\n    ForeignKey,\n    TIMESTAMP,\n    func,\n)\nfrom sqlalchemy.orm import declarative_base, relationship\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nfrom infra.db import get_engine, get_session, bootstrap_after_create\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(255), nullable=False)\n    email = Column(String(255), unique=True, nullable=False)\n    password = Column(String(255), nullable=False)\n    sex = Column(String(10), nullable=False)\n    birth_year = Column(Integer, nullable=False)\n    level = Column(String(10), nullable=False)\n    category = Column(String(20), nullable=False)\n    age = Column(Integer, nullable=False)\n    scores = relationship(\"Score\", back_populates=\"user\", cascade=\"all, delete\")\n\nclass Score(Base):\n    __tablename__ = \"scores\"\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    wod = Column(String(10), nullable=False)             # '26.1' etc.\n    score = Column(String(20), nullable=False)           # 'MM:SS' ou r√©p√©titions\n    created_at = Column(TIMESTAMP, server_default=func.now())\n    user = relationship(\"User\", back_populates=\"scores\")\n\nclass Wod(Base):\n    __tablename__ = \"wods\"\n    wod = Column(String(10), primary_key=True)           # '26.1'\n    label = Column(String(100), nullable=False)\n    type = Column(String(10), nullable=False)            # 'time' | 'reps'\n    timecap_seconds = Column(Integer, nullable=True)     # cap en secondes\n\n# Cr√©ation des tables puis bootstrap auto (seed + index)\nBase.metadata.create_all(get_engine())\nbootstrap_after_create()\n\ndef calculate_age_category(birth_year, current_year=datetime.now().year):\n    age = current_year - birth_year\n    if age <= 17:\n        category = \"Teenager\"\n    elif age < 35:\n        category = \"Elite\"\n    else:\n        category = \"Masters\"\n    return age, category\n\ndef login():\n    if \"user\" not in st.session_state:\n        st.session_state[\"user\"] = None\n\n    if st.session_state[\"user\"] is None:\n        st.subheader(\"Login / Register\")\n\n        with st.form(key=\"register_form\"):\n            name = st.text_input(\"Full Name\")\n            email = st.text_input(\"Email\")\n            password = st.text_input(\"Password\", type=\"password\")\n            sex = st.radio(\"Sex\", [\"Male\", \"Female\"])\n            birth_year = st.number_input(\"Year of Birth\", min_value=1950, max_value=datetime.now().year)\n            level = st.radio(\"Workout Level\", [\"Scaled\", \"RX\"])\n            submit_button = st.form_submit_button(\"Register\")\n\n            if submit_button:\n                if not name or not email or not password or not birth_year:\n                    st.error(\"Please fill in all the fields.\")\n                else:\n                    age, category = calculate_age_category(birth_year)\n                    with get_session() as session:\n                        existing_user = session.query(User).filter_by(email=email).first()\n                        if existing_user:\n                            st.error(\"Email already registered. Please login.\")\n                        else:\n                            hashed_password = generate_password_hash(password, method=\"pbkdf2:sha256\")\n                            new_user = User(\n                                name=name, email=email, password=hashed_password,\n                                sex=sex, birth_year=birth_year, level=level,\n                                category=category, age=age,\n                            )\n                            session.add(new_user)\n                            st.session_state[\"user\"] = {\n                                \"name\": name, \"email\": email, \"sex\": sex,\n                                \"birth_year\": birth_year, \"level\": level,\n                                \"category\": category, \"age\": age,\n                            }\n                            st.success(f\"Welcome {name}! You are categorized as {category} ({age} years old).\")\n\n        st.subheader(\"Or Login:\")\n        with st.form(key=\"login_form\"):\n            email_login = st.text_input(\"Email\")\n            password_login = st.text_input(\"Password\", type=\"password\")\n            submit_button_login = st.form_submit_button(\"Login\")\n\n            if submit_button_login:\n                with get_session(readonly=True) as session:\n                    user = session.query(User).filter_by(email=email_login).first()\n                    if user and check_password_hash(user.password, password_login):\n                        st.session_state[\"user\"] = {\n                            \"name\": user.name, \"email\": user.email, \"sex\": user.sex,\n                            \"birth_year\": user.birth_year, \"level\": user.level,\n                            \"category\": user.category, \"age\": user.age,\n                        }\n                        st.success(f\"Logged in as {user.name}\")\n                    else:\n                        st.error(\"Invalid email or password. Please try again.\")\n    else:\n        st.subheader(f\"Hello {st.session_state['user']['name']}!\")\n        if st.button(\"Logout\"):\n            st.session_state[\"user\"] = None\n            st.success(\"Logged out successfully.\")\n\nlogin()\n\ndef change_password():\n    st.subheader(\"Change Password if you want:\")\n    with get_session() as session:\n        user = session.query(User).filter_by(email=st.session_state[\"user\"][\"email\"]).first()\n        if user:\n            with st.form(key=\"change_password_form\"):\n                old_password = st.text_input(\"Old Password\", type=\"password\")\n                new_password = st.text_input(\"New Password\", type=\"password\")\n                confirm_password = st.text_input(\"Confirm New Password\", type=\"password\")\n                submit_button = st.form_submit_button(\"Change Password\")\n\n                if submit_button:\n                    if not old_password or not new_password or not confirm_password:\n                        st.error(\"All fields are required.\")\n                    elif not check_password_hash(user.password, old_password):\n                        st.error(\"Incorrect old password.\")\n                    elif new_password != confirm_password:\n                        st.error(\"New passwords do not match.\")\n                    else:\n                        user.password = generate_password_hash(new_password, method=\"pbkdf2:sha256\")\n                        st.success(\"Your password has been updated successfully!\")\n\nif st.session_state.get(\"user\"):\n    change_password()\n"
  },
  {
    "path": "pages/Classement.py",
    "content_after": "import streamlit as st\nfrom infra.db import get_session\nfrom pages.Authentification import Score, User, Wod\n\nst.title(\"Classement des Athl√®tes\")\n\nsex_selected = st.selectbox(\"Sexe\", [\"Male\", \"Female\"], index=0)\nlevel_selected = st.selectbox(\"Niveau\", [\"RX\", \"Scaled\", \"Coach\"], index=0)\nwod_selected = st.selectbox(\"Choisissez le WOD\", [\"Overall\", \"26.1\", \"26.2\", \"26.3\"])\n\ndef _score_to_seconds(score_str: str) -> int | None:\n    try:\n        parts = list(map(int, score_str.split(\":\")))\n        if len(parts) == 2:\n            return parts[0] * 60 + parts[1]\n        elif len(parts) == 3:\n            return parts[0] * 3600 + parts[1] * 60 + parts[2]\n    except Exception:\n        return None\n    return None\n\ndef _get_wod(wod: str):\n    with get_session(readonly=True) as s:\n        return s.query(Wod).filter(Wod.wod == wod).first()\n\ndef calculer_classement(wod: str, sex: str, level: str):\n    with get_session(readonly=True) as s:\n        rows = (\n            s.query(User.name, User.level, User.sex, Score.score)\n            .join(Score, User.id == Score.user_id)\n            .filter(Score.wod == wod, User.sex == sex, User.level == level)\n            .all()\n        )\n\n    if not rows:\n        return {}, {}\n\n    wod_meta = _get_wod(wod)\n    wod_type = (wod_meta.type if wod_meta else \"reps\")\n\n    classement, raw_scores = {}, {}\n    for name, level, sex, score in rows:\n        raw_scores.setdefault((name, level, sex), {})[wod] = score\n        if wod_type == \"time\":\n            secs = _score_to_seconds(score)\n            classement.setdefault((level, sex), []).append((name, secs if secs is not None else 10**9))\n        else:\n            try:\n                classement.setdefault((level, sex), []).append((name, int(score)))\n            except Exception:\n                classement.setdefault((level, sex), []).append((name, 0))\n\n    for key in classement:\n        if wod_type == \"time\":\n            classement[key] = sorted(classement[key], key=lambda x: x[1])           # ASC\n        else:\n            classement[key] = sorted(classement[key], key=lambda x: x[1], reverse=True)  # DESC\n    return classement, raw_scores\n\nif wod_selected == \"Overall\":\n    general_classement, scores_details = {}, {}\n    for wod in [\"26.1\", \"26.2\", \"26.3\"]:\n        wod_classement, wod_scores = calculer_classement(wod, sex_selected, level_selected)\n        for (level, sex), athletes in wod_classement.items():\n            for i, (name, _) in enumerate(athletes):\n                general_classement.setdefault((name, level, sex), 0)\n                general_classement[(name, level, sex)] += i + 1\n                scores_details.setdefault((name, level, sex), {}).update(wod_scores.get((name, level, sex), {}))\n\n    sorted_general = sorted(general_classement.items(), key=lambda x: x[1])\n    st.table({\n        \"Place\": [i + 1 for i in range(len(sorted_general))],\n        \"Nom\": [c[0][0] for c in sorted_general],\n        \"Niveau\": [c[0][1] for c in sorted_general],\n        \"Sexe\": [c[0][2] for c in sorted_general],\n        \"26.1\": [scores_details[c[0]].get(\"26.1\", \"-\") for c in sorted_general],\n        \"26.2\": [scores_details[c[0]].get(\"26.2\", \"-\") for c in sorted_general],\n        \"26.3\": [scores_details[c[0]].get(\"26.3\", \"-\") for c in sorted_general],\n        \"Points Totaux\": [c[1] for c in sorted_general],\n    })\nelse:\n    classement, scores_details = calculer_classement(wod_selected, sex_selected, level_selected)\n    for (level, sex), athletes in classement.items():\n        st.subheader(f\"Classement {level} - {sex}\")\n        sorted_classement = [(name, scores_details[(name, level, sex)][wod_selected]) for name, _ in athletes]\n        st.table({\n            \"Place\": [i + 1 for i in range(len(sorted_classement))],\n            \"Nom\": [c[0] for c in sorted_classement],\n            \"Score\": [c[1] for c in sorted_classement],\n            \"Points\": [i + 1 for i in range(len(sorted_classement))],\n        })\n"
  },
  {
    "path": "pages/Saisie_scores.py",
    "content_after": "from datetime import datetime\nimport re\nimport streamlit as st\nfrom infra.db import get_session\nfrom pages.Authentification import Score, User, Wod\n\nst.title(\"Saisie des Scores des WODs\")\n\nuser = st.session_state.get(\"user\")\nif not user:\n    st.warning(\"Veuillez vous connecter pour enregistrer votre score => onglet Authentification (Barre Laterale Gauche)\")\n    st.stop()\n\nwith get_session(readonly=True) as s:\n    user_db = s.query(User).filter_by(email=user[\"email\"]).first()\n\nwod_descriptions = {\n    \"26.1\": \"\"\"\n**26.1** AMRAP 15 minutes \\n\n3 lateral burpees over the dumbbell\\n\n3 dumbbell hang clean-to-overheads\\n\n30-foot walking lunge (2 x 15 feet)\\n\n**After completing each round, add 3 reps to the burpees and hang clean-to-overheads.**\\n\n‚ôÄÔ∏è 35-lb (15-kg) dumbbell / ‚ôÇÔ∏è 50-lb (22.5-kg) dumbbell\n\"\"\",\n    \"26.2\": \"\"\"\n**26.2** (22.3 repeat) For time :\\n\n21 pull-ups\\n\n42 double-unders\\n\n21 thrusters (weight 1)\\n\n18 chest-to-bar pull-ups\\n\n36 double-unders\\n\n18 thrusters (weight 2)\\n\n15 bar muscle-ups\\n\n30 double-unders\\n\n15 thrusters (weight 3) \\n\n**Time cap: 12 minutes**\\n\n‚ôÄÔ∏è 65, 75, 85 lb (29, 34, 38 kg)  / ‚ôÇÔ∏è 95, 115, 135 lb (43, 52, 61 kg)\n\"\"\",\n    \"26.3\": \"\"\"\n**26.3** For time :\\n\n5 wall walks\\n\n50-calorie row\\n\n5 wall walks\\n\n26 deadlifts\\n\n5 wall walks\\n\n26 cleans\\n\n5 wall walks\\n\n26 snatches\\n\n5 wall walks\\n\n50-calorie row\\n\n**Time cap: 20 minutes**\\n\n‚ôÄÔ∏è 155-lb (70-kg) deadlift, 85-lb (38-kg) clean, 65-lb (29-kg) snatch  / ‚ôÇÔ∏è 225-lb (102-kg) deadlift, 135-lb (61-kg) clean, 95-lb (43-kg) snatch\n\"\"\",\n}\n\nscore_instructions = {\n    \"26.3\": \"\"\"\n    üèãÔ∏è **Comment entrer votre score ?**\n    - Si vous terminez avant la limite de temps, entrez **MM:SS**.\n    - Si vous n‚Äôavez pas termin√© avant le time cap :\n      - **Entrez \"CAP:XX\"**, o√π **XX = 1 seconde par r√©p√©tition manquante** (ex: 12' => CAP:05 => 725 s si cap=720).\n    \"\"\",\n    \"26.1\": \"\"\"\nüî• **Comment entrer votre score ?**  \n- Ce WOD est un **AMRAP de 15 minutes**.  \n- Entrez **le nombre total de r√©p√©titions**.\n\"\"\",\n}\n\ndef normalize_time_score(input_str: str, timecap_seconds: int) -> int | None:\n    if not input_str:\n        return None\n    s = input_str.strip().upper()\n    m = re.match(r\"^CAP:(\\d{1,3})$\", s)\n    if m:\n        return timecap_seconds + int(m.group(1))\n    try:\n        parts = list(map(int, s.split(\":\")))\n        if len(parts) == 2:\n            return parts[0] * 60 + parts[1]\n        elif len(parts) == 3:\n            return parts[0] * 3600 + parts[1] * 60 + parts[2]\n    except Exception:\n        return None\n    return None\n\nif user_db:\n    wod = st.selectbox(\"S√©lectionner le WOD\", [\"26.1\", \"26.2\", \"26.3\"])\n    st.markdown(f\"### WOD {wod}\")\n    st.markdown(wod_descriptions[wod])\n    st.markdown(\"---\")\n    st.markdown(score_instructions.get(wod, \"\"))\n    st.markdown(\"---\")\n\n    with get_session(readonly=True) as s:\n        wod_meta = s.query(Wod).filter(Wod.wod == wod).first()\n        existing_score = s.query(Score).filter_by(user_id=user_db.id, wod=wod).first()\n\n    if existing_score:\n        st.warning(f\"Score actuel pour {wod} : {existing_score.score}\")\n        modify = st.checkbox(\"Modifier votre score ?\")\n    else:\n        modify = True\n\n    if modify:\n        new_score = None\n        if wod_meta and wod_meta.type == \"time\":\n            score_input = st.text_input(\n                \"Entrez votre score (format 'MM:SS' ou 'CAP:XX')\",\n                existing_score.score if existing_score else \"\",\n            )\n            seconds = normalize_time_score(score_input, wod_meta.timecap_seconds or 0)\n            if score_input and seconds is None:\n                st.error(\"Format incorrect. Utilisez 'MM:SS' ou 'CAP:XX'.\")\n            new_score = score_input if seconds is not None else None\n        else:\n            reps_val = st.number_input(\n                \"Entrez votre nombre de r√©p√©titions\",\n                min_value=0,\n                step=1,\n                value=int(existing_score.score) if (existing_score and existing_score.score.isdigit()) else 0,\n            )\n            new_score = str(reps_val)\n\n        if st.button(\"Enregistrer\" if not existing_score else \"Mettre √† jour\"):\n            if new_score:\n                with get_session() as s:\n                    if existing_score:\n                        existing_score.score = str(new_score)\n                    else:\n                        s.add(Score(user_id=user_db.id, wod=wod, score=str(new_score)))\n                st.success(\"Score enregistr√© avec succ√®s !\")\nelse:\n    st.warning(\"Utilisateur introuvable ‚Äî reconnectez-vous.\")\n"
  },
  {
    "path": "pages/Statistics.py",
    "content_after": "import numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport streamlit as st\n\nfrom infra.db import get_session\nfrom pages.Authentification import Score, User, Wod\n\nst.title(\"Statistiques des Scores des WODs\")\n\ndef normalize_for_stats(value: str, wod_type: str, timecap: int | None) -> float | None:\n    \"\"\"\n    - 'time' : renvoie des secondes (float), comprend 'MM:SS' et 'CAP:XX' (cap + XX).\n    - 'reps' : renvoie un entier (float) repr√©sentant les r√©p√©titions.\n    \"\"\"\n    if wod_type == \"time\":\n        if not value:\n            return None\n        s = value.strip().upper()\n        if s.startswith(\"CAP:\"):\n            try:\n                over = int(s.split(\":\")[1])\n                return float((timecap or 0) + over)\n            except Exception:\n                return None\n        try:\n            parts = list(map(int, s.split(\":\")))\n            if len(parts) == 2:\n                return float(parts[0] * 60 + parts[1])\n            elif len(parts) == 3:\n                return float(parts[0] * 3600 + parts[1] * 60 + parts[2])\n        except Exception:\n            return None\n        return None\n    else:\n        try:\n            return float(int(value))\n        except Exception:\n            return None\n\n# Charger toutes les lignes n√©cessaires avec jointure Wod\nwith get_session(readonly=True) as s:\n    rows = (\n        s.query(\n            User.name, User.sex, User.level, User.category,\n            Score.wod, Score.score, Wod.type, Wod.timecap_seconds\n        )\n        .join(Score, User.id == Score.user_id)\n        .join(Wod, Wod.wod == Score.wod)\n        .all()\n    )\n\nif not rows:\n    st.info(\"Aucune donn√©e.\")\n    st.stop()\n\ndata = pd.DataFrame(\n    rows,\n    columns=[\"Nom\", \"Sexe\", \"Niveau\", \"Cat√©gorie\", \"WOD\", \"ScoreBrut\", \"Type\", \"CapSec\"]\n)\n# Normaliser en valeur num√©rique exploitable\ndata[\"Score\"] = data.apply(\n    lambda r: normalize_for_stats(r[\"ScoreBrut\"], r[\"Type\"], r[\"CapSec\"]), axis=1\n)\n\nst.subheader(\"Statistiques par WOD\")\n# WODs disponibles depuis la table\nwods = sorted(data[\"WOD\"].unique().tolist())\nwod_selected = st.selectbox(\"Choisissez un WOD\", wods, index=0 if wods else None)\n\nsubset = data[(data[\"WOD\"] == wod_selected)].copy()\nif subset.empty:\n    st.info(\"Aucune donn√©e pour ce WOD.\")\n    st.stop()\n\n# Percentiles s√©par√©s H/F\npercentiles = np.arange(0, 101, 10)\nmale = subset[subset[\"Sexe\" ] == \"Male\"][\"Score\"].dropna()\nfemale = subset[subset[\"Sexe\"] == \"Female\"][\"Score\"].dropna()\n\n# Pour les 'time', score = secondes => percentiles invers√©s pour tracer des 'meilleurs = plus bas'\nis_time = (subset[\"Type\"].iloc[0] == \"time\")\nif is_time:\n    male_percentiles = (np.percentile(male, 100 - percentiles) if not male.empty else np.zeros_like(percentiles))\n    female_percentiles = (np.percentile(female, 100 - percentiles) if not female.empty else np.zeros_like(percentiles))\nelse:\n    male_percentiles = (np.percentile(male, percentiles) if not male.empty else np.zeros_like(percentiles))\n    female_percentiles = (np.percentile(female, percentiles) if not female.empty else np.zeros_like(percentiles))\n\ndf_plot = pd.DataFrame({\n    \"Percentiles\": percentiles.tolist() * 2,\n    \"Score\": np.concatenate([male_percentiles, female_percentiles]),\n    \"Sexe\": [\"Hommes\"] * len(percentiles) + [\"Femmes\"] * len(percentiles),\n})\n\ntitle = f\"Distribution des Scores - {wod_selected} ({'temps' if is_time else 'r√©p√©titions'})\"\nfig = px.line(\n    df_plot, x=\"Percentiles\", y=\"Score\", color=\"Sexe\",\n    markers=True, title=title,\n    color_discrete_map={\"Hommes\": \"#89b385\", \"Femmes\": \"#dcaa78\"},\n)\nst.plotly_chart(fig)\n\n# Statistiques compl√©mentaires\nif is_time:\n    st.subheader(\"Statistiques Temps\")\n    male_mean = male.mean() if not male.empty else 0\n    female_mean = female.mean() if not female.empty else 0\n    time_cap = int(subset[\"CapSec\"].iloc[0] or 0)\n    pct_m_before = (male < time_cap).mean() * 100 if (time_cap and not male.empty) else 0\n    pct_f_before = (female < time_cap).mean() * 100 if (time_cap and not female.empty) else 0\n\n    st.write(f\"Temps moyen Hommes : {male_mean:.2f} s\")\n    st.write(f\"Temps moyen Femmes : {female_mean:.2f} s\")\n    if time_cap:\n        st.write(f\"Hommes terminant avant cap : {pct_m_before:.2f}%\")\n        st.write(f\"Femmes terminant avant cap : {pct_f_before:.2f}%\")\nelse:\n    st.subheader(\"Statistiques R√©p√©titions\")\n    male_mean = male.mean() if not male.empty else 0\n    female_mean = female.mean() if not female.empty else 0\n    st.write(f\"R√©p√©titions moyennes Hommes : {male_mean:.0f}\")\n    st.write(f\"R√©p√©titions moyennes Femmes : {female_mean:.0f}\")\n\n# R√©partition des participants par sexe et niveau\nst.subheader(\"R√©partition des Participants par Sexe et Niveau\")\ngender_level_count = subset.groupby([\"Sexe\", \"Niveau\"]).size().reset_index(name=\"Nombre\")\nfig_level = px.bar(\n    gender_level_count, x=\"Niveau\", y=\"Nombre\", color=\"Sexe\", barmode=\"group\",\n    title=\"R√©partition par sexe et niveau\",\n    labels={\"Niveau\": \"Niveau\", \"Nombre\": \"Nombre de participants\"},\n    color_discrete_map={\"Male\": \"#89b385\", \"Female\": \"#dcaa78\"},\n)\nst.plotly_chart(fig_level)\n"
  },
  {
    "path": "README.md",
    "content_after": "# 2026 CrossFit Games Open ‚Äî Box Interne\n\nApplication de suivi des scores pour l'Open CrossFit 2026, optimis√©e pour une gestion interne en box.\n\n## Fonctionnalit√©s\n- **Authentification** : Inscription et gestion de profil (Sexe, Niveau RX/Scaled, Cat√©gorie d'√¢ge).\n- **Saisie des Scores** : Interface d√©di√©e pour les WODs 26.1, 26.2 et 26.3 avec validation des formats (Reps ou Temps/CAP).\n- **Classement Dynamique** : Leaderboard filtrable par sexe et niveau, incluant un classement g√©n√©ral (Overall) bas√© sur les points.\n- **Statistiques Avanc√©es** : Visualisation de la distribution des scores (percentiles) et analyses par cat√©gorie.\n\n## Stack Technique\n- **Framework** : [Streamlit](https://streamlit.io)\n- **Base de Donn√©es** : [Neon Postgres 17](https://neon.tech) (Serverless)\n- **ORM** : SQLAlchemy 2.0\n- **Analyse de donn√©es** : Pandas, Numpy, Plotly\n\n## Configuration & D√©ploiement\n\n### Base de donn√©es\nL'application utilise Neon Postgres. La structure des tables et les donn√©es initiales (WODs) sont cr√©√©es automatiquement au premier d√©marrage.\n\n**Secrets requis (Streamlit Cloud ou .streamlit/secrets.toml) :**\n```toml\n[database]\nurl = \"postgresql://user:password@ep-xxx.aws.neon.tech/neondb?sslmode=require\"\n```\n\n### Installation locale\n1. Cloner le d√©p√¥t.\n2. Installer les d√©pendances : `pip install -r requirements.txt` (g√©n√©r√© via `pip-compile requirements.in`).\n3. Configurer la variable d'environnement `DATABASE_URL` ou le fichier `secrets.toml`.\n4. Lancer : `streamlit run Home.py`.\n\n## S√©curit√©\n- Mots de passe hach√©s via PBKDF2 (Werkzeug).\n- Connexions DB s√©curis√©es (SSL requis).\n- Isolation des sessions via SQLAlchemy.\n"
  },
  {
    "path": "requirements.in",
    "content_after": "streamlit\nsqlalchemy\npsycopg2-binary\nwerkzeug\nnumpy\npandas\nplotly-express\n"
  }
]