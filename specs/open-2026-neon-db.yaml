feature: "Neon Postgres 17 ‚Äî Int√©gration propre + mod√®le de scoring 2026 (bootstrap auto)"

description: >
  Int√©gration DB sans secret en dur et sans √©tape manuelle :
  - Connexion via st.secrets (fallback os.getenv).
  - Engine SQLAlchemy global (pool queuepool=5, pre_ping, recycle).
  - Table 'wods' + index cr√©√©s/seed√©s automatiquement (idempotent).
  - Classement/Saisie_scores/Statistics uniformis√©s sur 'wods'.
  - Transactions read-only c√¥t√© lecture.

prerequisites:
  - "Cr√©er un projet Neon (Postgres 17) et mettre l‚ÄôURL en secret : Streamlit Cloud (secrets.toml) + GitHub (DATABASE_URL)."
  - "Ne pas activer Neon Auth : non requis pour l‚Äôapplication."
  - "Aucune commande psql √† ex√©cuter : bootstrap auto code-side."

acceptance_criteria:
  - "Connexion DB : st.secrets['database']['url'] avec fallback os.getenv('DATABASE_URL')."
  - "Engine global : pool_size=5, max_overflow=0, pool_pre_ping=true, pool_recycle=1800."
  - "Fonctions de session : get_session(readonly=True/False) ; lecture en read-only."
  - "Table 'wods' pr√©sente et seed√©e (26.1 reps, 26.2 time cap 12', 26.3 time cap 20')."
  - "Index : scores(user_id,wod) et users(sex,level)."
  - "Classement/Saisie_scores/Statistics lisent type/timecap depuis 'wods'."
  - "Saisie : normalisation temps 'MM:SS' / 'CAP:XX' (cap + XX)."
  - "Statistics : plus aucune liste cod√©e en dur ; percentiles/means bas√©s sur seconds pour 'time'."
  - "ruff/bandit/pip-audit OK sur les fichiers modifi√©s/ajout√©s."

constraints:
  forbidden_globs: [".github/**", ".venv/**", "credentials/**", "**/*.key", "**/*.pem"]
  allowed_roots: ["", "pages", "infra", "db", "specs"]

tasks:

  - id: db_core_module
    desc: "Cr√©er 'infra/db.py' : engine global + sessions + bootstrap auto (seed wods + index)."
    files:
      - path: infra/db.py
        action: create
        content: |
          # infra/db.py
          from __future__ import annotations

          import os
          from contextlib import contextmanager
          from typing import Iterator, Optional

          # Streamlit peut ne pas √™tre dispo en contexte tests -> importer prudemment
          try:
              import streamlit as st  # type: ignore
          except Exception:  # pragma: no cover
              st = None  # type: ignore

          from sqlalchemy import create_engine, text
          from sqlalchemy.engine import Engine
          from sqlalchemy.orm import sessionmaker, Session

          _ENGINE: Optional[Engine] = None
          _SESSION_FACTORY: Optional[sessionmaker] = None
          _BOOTSTRAPPED: bool = False

          def _db_url() -> str:
              # 1) Streamlit secrets  2) fallback os.getenv
              url = None
              try:
                  if st is not None:
                      url = st.secrets.get("database", {}).get("url")  # type: ignore
              except Exception:
                  pass
              return url or os.getenv("DATABASE_URL", "")

          def get_engine() -> Engine:
              global _ENGINE, _SESSION_FACTORY
              if _ENGINE is None:
                  url = _db_url()
                  if not url:
                      raise RuntimeError(
                          "DATABASE_URL manquant (st.secrets['database']['url'] ou variable d'environnement)."
                      )
                  _ENGINE = create_engine(
                      url,
                      pool_size=5,
                      max_overflow=0,
                      pool_pre_ping=True,
                      pool_recycle=1800,
                      future=True,
                  )
                  _SESSION_FACTORY = sessionmaker(bind=_ENGINE, expire_on_commit=False, future=True)
              return _ENGINE

          @contextmanager
          def get_session(readonly: bool = False) -> Iterator[Session]:
              if _SESSION_FACTORY is None:
                  get_engine()
              assert _SESSION_FACTORY is not None
              session = _SESSION_FACTORY()
              try:
                  if readonly:
                      session.execute(text("SET TRANSACTION READ ONLY"))
                  yield session
                  if not readonly:
                      session.commit()
              except Exception:
                  session.rollback()
                  raise
              finally:
                  session.close()

          def bootstrap_after_create() -> None:
              """
              Idempotent : ins√®re les WODs 26.x + cr√©e les index si absents.
              Appel√©e apr√®s Base.metadata.create_all(...).
              """
              global _BOOTSTRAPPED
              if _BOOTSTRAPPED:
                  return
              engine = get_engine()
              with engine.begin() as conn:
                  # Seed 'wods' (ON CONFLICT pour idempotence)
                  conn.execute(text("""
                      INSERT INTO wods (wod, label, type, timecap_seconds)
                      VALUES 
                        ('26.1', 'Open 26.1', 'reps', NULL),
                        ('26.2', 'Open 26.2', 'time', 12*60),
                        ('26.3', 'Open 26.3', 'time', 20*60)
                      ON CONFLICT (wod) DO NOTHING;
                  """))

                  # Index idempotents
                  conn.execute(text("CREATE INDEX IF NOT EXISTS idx_scores_user_wod ON scores(user_id, wod);"))
                  conn.execute(text("CREATE INDEX IF NOT EXISTS idx_users_sex_level ON users(sex, level);"))
              _BOOTSTRAPPED = True

  - id: models_and_engine_injection
    desc: "Adapter pages/Authentification.py : engine via infra.db, ajout mod√®le Wod, create_all + bootstrap."
    files:
      - path: pages/Authentification.py
        action: modify
        content_after: |
          import streamlit as st
          from datetime import datetime
          from sqlalchemy import (
              Column,
              Integer,
              String,
              ForeignKey,
              TIMESTAMP,
              func,
          )
          from sqlalchemy.orm import declarative_base, relationship
          from werkzeug.security import generate_password_hash, check_password_hash

          from infra.db import get_engine, get_session, bootstrap_after_create

          Base = declarative_base()

          class User(Base):
              __tablename__ = "users"
              id = Column(Integer, primary_key=True)
              name = Column(String(255), nullable=False)
              email = Column(String(255), unique=True, nullable=False)
              password = Column(String(255), nullable=False)
              sex = Column(String(10), nullable=False)
              birth_year = Column(Integer, nullable=False)
              level = Column(String(10), nullable=False)
              category = Column(String(20), nullable=False)
              age = Column(Integer, nullable=False)
              scores = relationship("Score", back_populates="user", cascade="all, delete")

          class Score(Base):
              __tablename__ = "scores"
              id = Column(Integer, primary_key=True)
              user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
              wod = Column(String(10), nullable=False)             # '26.1' etc.
              score = Column(String(20), nullable=False)           # 'MM:SS' ou r√©p√©titions
              created_at = Column(TIMESTAMP, server_default=func.now())
              user = relationship("User", back_populates="scores")

          class Wod(Base):
              __tablename__ = "wods"
              wod = Column(String(10), primary_key=True)           # '26.1'
              label = Column(String(100), nullable=False)
              type = Column(String(10), nullable=False)            # 'time' | 'reps'
              timecap_seconds = Column(Integer, nullable=True)     # cap en secondes

          # Cr√©ation des tables puis bootstrap auto (seed + index)
          Base.metadata.create_all(get_engine())
          bootstrap_after_create()

          def calculate_age_category(birth_year, current_year=datetime.now().year):
              age = current_year - birth_year
              if age <= 17:
                  category = "Teenager"
              elif age < 35:
                  category = "Elite"
              else:
                  category = "Masters"
              return age, category

          def login():
              if "user" not in st.session_state:
                  st.session_state["user"] = None

              if st.session_state["user"] is None:
                  st.subheader("Login / Register")

                  with st.form(key="register_form"):
                      name = st.text_input("Full Name")
                      email = st.text_input("Email")
                      password = st.text_input("Password", type="password")
                      sex = st.radio("Sex", ["Male", "Female"])
                      birth_year = st.number_input("Year of Birth", min_value=1950, max_value=datetime.now().year)
                      level = st.radio("Workout Level", ["Scaled", "RX"])
                      submit_button = st.form_submit_button("Register")

                      if submit_button:
                          if not name or not email or not password or not birth_year:
                              st.error("Please fill in all the fields.")
                          else:
                              age, category = calculate_age_category(birth_year)
                              with get_session() as session:
                                  existing_user = session.query(User).filter_by(email=email).first()
                                  if existing_user:
                                      st.error("Email already registered. Please login.")
                                  else:
                                      hashed_password = generate_password_hash(password, method="pbkdf2:sha256")
                                      new_user = User(
                                          name=name, email=email, password=hashed_password,
                                          sex=sex, birth_year=birth_year, level=level,
                                          category=category, age=age,
                                      )
                                      session.add(new_user)
                                      st.session_state["user"] = {
                                          "name": name, "email": email, "sex": sex,
                                          "birth_year": birth_year, "level": level,
                                          "category": category, "age": age,
                                      }
                                      st.success(f"Welcome {name}! You are categorized as {category} ({age} years old).")

                  st.subheader("Or Login:")
                  with st.form(key="login_form"):
                      email_login = st.text_input("Email")
                      password_login = st.text_input("Password", type="password")
                      submit_button_login = st.form_submit_button("Login")

                      if submit_button_login:
                          with get_session(readonly=True) as session:
                              user = session.query(User).filter_by(email=email_login).first()
                              if user and check_password_hash(user.password, password_login):
                                  st.session_state["user"] = {
                                      "name": user.name, "email": user.email, "sex": user.sex,
                                      "birth_year": user.birth_year, "level": user.level,
                                      "category": user.category, "age": user.age,
                                  }
                                  st.success(f"Logged in as {user.name}")
                              else:
                                  st.error("Invalid email or password. Please try again.")
              else:
                  st.subheader(f"Hello {st.session_state['user']['name']}!")
                  if st.button("Logout"):
                      st.session_state["user"] = None
                      st.success("Logged out successfully.")

          login()

          def change_password():
              st.subheader("Change Password if you want:")
              with get_session() as session:
                  user = session.query(User).filter_by(email=st.session_state["user"]["email"]).first()
                  if user:
                      with st.form(key="change_password_form"):
                          old_password = st.text_input("Old Password", type="password")
                          new_password = st.text_input("New Password", type="password")
                          confirm_password = st.text_input("Confirm New Password", type="password")
                          submit_button = st.form_submit_button("Change Password")

                          if submit_button:
                              if not old_password or not new_password or not confirm_password:
                                  st.error("All fields are required.")
                              elif not check_password_hash(user.password, old_password):
                                  st.error("Incorrect old password.")
                              elif new_password != confirm_password:
                                  st.error("New passwords do not match.")
                              else:
                                  user.password = generate_password_hash(new_password, method="pbkdf2:sha256")
                                  st.success("Your password has been updated successfully!")

          if st.session_state.get("user"):
              change_password()

  - id: classement_update
    desc: "Adapter pages/Classement.py : get_session(readonly), lecture Wod, tri ASC pour time / DESC pour reps."
    files:
      - path: pages/Classement.py
        action: modify
        content_after: |
          import streamlit as st
          from infra.db import get_session
          from pages.Authentification import Score, User, Wod

          st.title("Classement des Athl√®tes")

          sex_selected = st.selectbox("Sexe", ["Male", "Female"], index=0)
          level_selected = st.selectbox("Niveau", ["RX", "Scaled", "Coach"], index=0)
          wod_selected = st.selectbox("Choisissez le WOD", ["Overall", "26.1", "26.2", "26.3"])

          def _score_to_seconds(score_str: str) -> int | None:
              try:
                  parts = list(map(int, score_str.split(":")))
                  if len(parts) == 2:
                      return parts[0] * 60 + parts[1]
                  elif len(parts) == 3:
                      return parts[0] * 3600 + parts[1] * 60 + parts[2]
              except Exception:
                  return None
              return None

          def _get_wod(wod: str):
              with get_session(readonly=True) as s:
                  return s.query(Wod).filter(Wod.wod == wod).first()

          def calculer_classement(wod: str, sex: str, level: str):
              with get_session(readonly=True) as s:
                  rows = (
                      s.query(User.name, User.level, User.sex, Score.score)
                      .join(Score, User.id == Score.user_id)
                      .filter(Score.wod == wod, User.sex == sex, User.level == level)
                      .all()
                  )

              if not rows:
                  return {}, {}

              wod_meta = _get_wod(wod)
              wod_type = (wod_meta.type if wod_meta else "reps")

              classement, raw_scores = {}, {}
              for name, level, sex, score in rows:
                  raw_scores.setdefault((name, level, sex), {})[wod] = score
                  if wod_type == "time":
                      secs = _score_to_seconds(score)
                      classement.setdefault((level, sex), []).append((name, secs if secs is not None else 10**9))
                  else:
                      try:
                          classement.setdefault((level, sex), []).append((name, int(score)))
                      except Exception:
                          classement.setdefault((level, sex), []).append((name, 0))

              for key in classement:
                  if wod_type == "time":
                      classement[key] = sorted(classement[key], key=lambda x: x[1])           # ASC
                  else:
                      classement[key] = sorted(classement[key], key=lambda x: x[1], reverse=True)  # DESC
              return classement, raw_scores

          if wod_selected == "Overall":
              general_classement, scores_details = {}, {}
              for wod in ["26.1", "26.2", "26.3"]:
                  wod_classement, wod_scores = calculer_classement(wod, sex_selected, level_selected)
                  for (level, sex), athletes in wod_classement.items():
                      for i, (name, _) in enumerate(athletes):
                          general_classement.setdefault((name, level, sex), 0)
                          general_classement[(name, level, sex)] += i + 1
                          scores_details.setdefault((name, level, sex), {}).update(wod_scores.get((name, level, sex), {}))

              sorted_general = sorted(general_classement.items(), key=lambda x: x[1])
              st.table({
                  "Place": [i + 1 for i in range(len(sorted_general))],
                  "Nom": [c[0][0] for c in sorted_general],
                  "Niveau": [c[0][1] for c in sorted_general],
                  "Sexe": [c[0][2] for c in sorted_general],
                  "26.1": [scores_details[c[0]].get("26.1", "-") for c in sorted_general],
                  "26.2": [scores_details[c[0]].get("26.2", "-") for c in sorted_general],
                  "26.3": [scores_details[c[0]].get("26.3", "-") for c in sorted_general],
                  "Points Totaux": [c[1] for c in sorted_general],
              })
          else:
              classement, scores_details = calculer_classement(wod_selected, sex_selected, level_selected)
              for (level, sex), athletes in classement.items():
                  st.subheader(f"Classement {level} - {sex}")
                  sorted_classement = [(name, scores_details[(name, level, sex)][wod_selected]) for name, _ in athletes]
                  st.table({
                      "Place": [i + 1 for i in range(len(sorted_classement))],
                      "Nom": [c[0] for c in sorted_classement],
                      "Score": [c[1] for c in sorted_classement],
                      "Points": [i + 1 for i in range(len(sorted_classement))],
                  })

  - id: saisie_scores_update
    desc: "Adapter pages/Saisie_scores.py : session R/W, normalisation CAP:XX (cap+XX), lecture Wod pour type/cap."
    files:
      - path: pages/Saisie_scores.py
        action: modify
        content_after: |
          from datetime import datetime
          import re
          import streamlit as st
          from infra.db import get_session
          from pages.Authentification import Score, User, Wod

          st.title("Saisie des Scores des WODs")

          user = st.session_state.get("user")
          if not user:
              st.warning("Veuillez vous connecter pour enregistrer votre score => onglet Authentification (Barre Laterale Gauche)")
              st.stop()

          with get_session(readonly=True) as s:
              user_db = s.query(User).filter_by(email=user["email"]).first()

          wod_descriptions = {
              "26.1": """
          **26.1** AMRAP 15 minutes \n
          3 lateral burpees over the dumbbell\n
          3 dumbbell hang clean-to-overheads\n
          30-foot walking lunge (2 x 15 feet)\n
          **After completing each round, add 3 reps to the burpees and hang clean-to-overheads.**\n
          ‚ôÄÔ∏è 35-lb (15-kg) dumbbell / ‚ôÇÔ∏è 50-lb (22.5-kg) dumbbell
          """,
              "26.2": """
          **26.2** (22.3 repeat) For time :\n
          21 pull-ups\n
          42 double-unders\n
          21 thrusters (weight 1)\n
          18 chest-to-bar pull-ups\n
          36 double-unders\n
          18 thrusters (weight 2)\n
          15 bar muscle-ups\n
          30 double-unders\n
          15 thrusters (weight 3) \n
          **Time cap: 12 minutes**\n
          ‚ôÄÔ∏è 65, 75, 85 lb (29, 34, 38 kg)  / ‚ôÇÔ∏è 95, 115, 135 lb (43, 52, 61 kg)
          """,
              "26.3": """
          **26.3** For time :\n
          5 wall walks\n
          50-calorie row\n
          5 wall walks\n
          26 deadlifts\n
          5 wall walks\n
          26 cleans\n
          5 wall walks\n
          26 snatches\n
          5 wall walks\n
          50-calorie row\n
          **Time cap: 20 minutes**\n
          ‚ôÄÔ∏è 155-lb (70-kg) deadlift, 85-lb (38-kg) clean, 65-lb (29-kg) snatch  / ‚ôÇÔ∏è 225-lb (102-kg) deadlift, 135-lb (61-kg) clean, 95-lb (43-kg) snatch
          """,
          }

          score_instructions = {
              "26.3": """
              üèãÔ∏è **Comment entrer votre score ?**
              - Si vous terminez avant la limite de temps, entrez **MM:SS**.
              - Si vous n‚Äôavez pas termin√© avant le time cap :
                - **Entrez "CAP:XX"**, o√π **XX = 1 seconde par r√©p√©tition manquante** (ex: 12' => CAP:05 => 725 s si cap=720).
              """,
              "26.1": """
          üî• **Comment entrer votre score ?**  
          - Ce WOD est un **AMRAP de 15 minutes**.  
          - Entrez **le nombre total de r√©p√©titions**.
          """,
          }

          def normalize_time_score(input_str: str, timecap_seconds: int) -> int | None:
              if not input_str:
                  return None
              s = input_str.strip().upper()
              m = re.match(r"^CAP:(\d{1,3})$", s)
              if m:
                  return timecap_seconds + int(m.group(1))
              try:
                  parts = list(map(int, s.split(":")))
                  if len(parts) == 2:
                      return parts[0] * 60 + parts[1]
                  elif len(parts) == 3:
                      return parts[0] * 3600 + parts[1] * 60 + parts[2]
              except Exception:
                  return None
              return None

          if user_db:
              wod = st.selectbox("S√©lectionner le WOD", ["26.1", "26.2", "26.3"])
              st.markdown(f"### WOD {wod}")
              st.markdown(wod_descriptions[wod])
              st.markdown("---")
              st.markdown(score_instructions.get(wod, ""))
              st.markdown("---")

              with get_session(readonly=True) as s:
                  wod_meta = s.query(Wod).filter(Wod.wod == wod).first()
                  existing_score = s.query(Score).filter_by(user_id=user_db.id, wod=wod).first()

              if existing_score:
                  st.warning(f"Score actuel pour {wod} : {existing_score.score}")
                  modify = st.checkbox("Modifier votre score ?")
              else:
                  modify = True

              if modify:
                  new_score = None
                  if wod_meta and wod_meta.type == "time":
                      score_input = st.text_input(
                          "Entrez votre score (format 'MM:SS' ou 'CAP:XX')",
                          existing_score.score if existing_score else "",
                      )
                      seconds = normalize_time_score(score_input, wod_meta.timecap_seconds or 0)
                      if score_input and seconds is None:
                          st.error("Format incorrect. Utilisez 'MM:SS' ou 'CAP:XX'.")
                      new_score = score_input if seconds is not None else None
                  else:
                      reps_val = st.number_input(
                          "Entrez votre nombre de r√©p√©titions",
                          min_value=0,
                          step=1,
                          value=int(existing_score.score) if (existing_score and existing_score.score.isdigit()) else 0,
                      )
                      new_score = str(reps_val)

                  if st.button("Enregistrer" if not existing_score else "Mettre √† jour"):
                      if new_score:
                          with get_session() as s:
                              if existing_score:
                                  existing_score.score = str(new_score)
                              else:
                                  s.add(Score(user_id=user_db.id, wod=wod, score=str(new_score)))
                          st.success("Score enregistr√© avec succ√®s !")
          else:
              st.warning("Utilisateur introuvable ‚Äî reconnectez-vous.")

  - id: statistics_update
    desc: "Uniformiser pages/Statistics.py : lecture via get_session + jointure Wod pour typer/normaliser les scores."
    files:
      - path: pages/Statistics.py
        action: modify
        content_after: |
          import numpy as np
          import pandas as pd
          import plotly.express as px
          import streamlit as st

          from infra.db import get_session
          from pages.Authentification import Score, User, Wod

          st.title("Statistiques des Scores des WODs")

          def normalize_for_stats(value: str, wod_type: str, timecap: int | None) -> float | None:
              """
              - 'time' : renvoie des secondes (float), comprend 'MM:SS' et 'CAP:XX' (cap + XX).
              - 'reps' : renvoie un entier (float) repr√©sentant les r√©p√©titions.
              """
              if wod_type == "time":
                  if not value:
                      return None
                  s = value.strip().upper()
                  if s.startswith("CAP:"):
                      try:
                          over = int(s.split(":")[1])
                          return float((timecap or 0) + over)
                      except Exception:
                          return None
                  try:
                      parts = list(map(int, s.split(":")))
                      if len(parts) == 2:
                          return float(parts[0] * 60 + parts[1])
                      elif len(parts) == 3:
                          return float(parts[0] * 3600 + parts[1] * 60 + parts[2])
                  except Exception:
                      return None
                  return None
              else:
                  try:
                      return float(int(value))
                  except Exception:
                      return None

          # Charger toutes les lignes n√©cessaires avec jointure Wod
          with get_session(readonly=True) as s:
              rows = (
                  s.query(
                      User.name, User.sex, User.level, User.category,
                      Score.wod, Score.score, Wod.type, Wod.timecap_seconds
                  )
                  .join(Score, User.id == Score.user_id)
                  .join(Wod, Wod.wod == Score.wod)
                  .all()
              )

          if not rows:
              st.info("Aucune donn√©e.")
              st.stop()

          data = pd.DataFrame(
              rows,
              columns=["Nom", "Sexe", "Niveau", "Cat√©gorie", "WOD", "ScoreBrut", "Type", "CapSec"]
          )
          # Normaliser en valeur num√©rique exploitable
          data["Score"] = data.apply(
              lambda r: normalize_for_stats(r["ScoreBrut"], r["Type"], r["CapSec"]), axis=1
          )

          st.subheader("Statistiques par WOD")
          # WODs disponibles depuis la table
          wods = sorted(data["WOD"].unique().tolist())
          wod_selected = st.selectbox("Choisissez un WOD", wods, index=0 if wods else None)

          subset = data[(data["WOD"] == wod_selected)].copy()
          if subset.empty:
              st.info("Aucune donn√©e pour ce WOD.")
              st.stop()

          # Percentiles s√©par√©s H/F
          percentiles = np.arange(0, 101, 10)
          male = subset[subset["Sexe"] == "Male"]["Score"].dropna()
          female = subset[subset["Sexe"] == "Female"]["Score"].dropna()

          # Pour les 'time', score = secondes => percentiles invers√©s pour tracer des 'meilleurs = plus bas'
          is_time = (subset["Type"].iloc[0] == "time")
          if is_time:
              male_percentiles = (np.percentile(male, 100 - percentiles) if not male.empty else np.zeros_like(percentiles))
              female_percentiles = (np.percentile(female, 100 - percentiles) if not female.empty else np.zeros_like(percentiles))
          else:
              male_percentiles = (np.percentile(male, percentiles) if not male.empty else np.zeros_like(percentiles))
              female_percentiles = (np.percentile(female, percentiles) if not female.empty else np.zeros_like(percentiles))

          df_plot = pd.DataFrame({
              "Percentiles": percentiles.tolist() * 2,
              "Score": np.concatenate([male_percentiles, female_percentiles]),
              "Sexe": ["Hommes"] * len(percentiles) + ["Femmes"] * len(percentiles),
          })

          title = f"Distribution des Scores - {wod_selected} ({'temps' if is_time else 'r√©p√©titions'})"
          fig = px.line(
              df_plot, x="Percentiles", y="Score", color="Sexe",
              markers=True, title=title,
              color_discrete_map={"Hommes": "#89b385", "Femmes": "#dcaa78"},
          )
          st.plotly_chart(fig)

          # Statistiques compl√©mentaires
          if is_time:
              st.subheader("Statistiques Temps")
              male_mean = male.mean() if not male.empty else 0
              female_mean = female.mean() if not female.empty else 0
              time_cap = int(subset["CapSec"].iloc[0] or 0)
              pct_m_before = (male < time_cap).mean() * 100 if (time_cap and not male.empty) else 0
              pct_f_before = (female < time_cap).mean() * 100 if (time_cap and not female.empty) else 0

              st.write(f"Temps moyen Hommes : {male_mean:.2f} s")
              st.write(f"Temps moyen Femmes : {female_mean:.2f} s")
              if time_cap:
                  st.write(f"Hommes terminant avant cap : {pct_m_before:.2f}%")
                  st.write(f"Femmes terminant avant cap : {pct_f_before:.2f}%")
          else:
              st.subheader("Statistiques R√©p√©titions")
              male_mean = male.mean() if not male.empty else 0
              female_mean = female.mean() if not female.empty else 0
              st.write(f"R√©p√©titions moyennes Hommes : {male_mean:.0f}")
              st.write(f"R√©p√©titions moyennes Femmes : {female_mean:.0f}")

          # R√©partition des participants par sexe et niveau
          st.subheader("R√©partition des Participants par Sexe et Niveau")
          gender_level_count = subset.groupby(["Sexe", "Niveau"]).size().reset_index(name="Nombre")
          fig_level = px.bar(
              gender_level_count, x="Niveau", y="Nombre", color="Sexe", barmode="group",
              title="R√©partition par sexe et niveau",
              labels={"Niveau": "Niveau", "Nombre": "Nombre de participants"},
              color_discrete_map={"Male": "#89b385", "Female": "#dcaa78"},
          )
          st.plotly_chart(fig_level)

output_format: >
  Retourner STRICTEMENT un objet JSON :
  {"diffs":[
    {"path":"infra/db.py","content_after":"..."},
    {"path":"pages/Authentification.py","content_after":"..."},
    {"path":"pages/Classement.py","content_after":"..."},
    {"path":"pages/Saisie_scores.py","content_after":"..."},
    {"path":"pages/Statistics.py","content_after":"..."}
  ]}